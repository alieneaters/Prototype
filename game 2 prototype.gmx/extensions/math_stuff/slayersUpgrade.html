<html>
<head>
<style>
body {font-family:'Arial'; font-size:14px;}
b {font-family:'Courier New';}
</style>
</head>
<body><h1>CONTENTS</h1>click links to search. push home to come back to top.<br /><br /><a href='#0'>system</a></br><a href='#100'>vector</a></br><a href='#200'>quaternion</a></br><a href='#300'>screen convert</a></br><a href='#400'>spaces</a></br><a href='#500'>shapes</a></br><a href='#600'>ray tracing</a></br><a href='#700'>extra tracing</a></br><a href='#800'>3d grids</a></br><a href='#900'>files and strings</a></br><a href='#1000'>other</a></br><hr><h2 id='0'>system</h2><a href='#1'>slayersUpgradeInit</a></br><a href='#2'>slayersUpgradeDone</a></br><br /><b id='1'>slayersUpgradeInit()</b>        initializes slayers upgrade. declares some globalvar's that you might want to know about. slayersUpgrade is an instance id,     vectors: vTempa,vTempb,vTempc,vZero and quaternion: qTempa.    do not initalize twice! <br /><br /><b id='2'>slayersUpgradeDone()</b>        destroys the slayersUpgrade instance<br /><br /><hr><h2 id='100'>vector</h2><a href='#101'>vecCreate</a></br><a href='#102'>vecCreateCopy</a></br><a href='#103'>vecDestroy</a></br><a href='#104'>vecCopy</a></br><a href='#105'>vecx</a></br><a href='#106'>vecy</a></br><a href='#107'>vecz</a></br><a href='#108'>vecAdd</a></br><a href='#109'>vecAddScale</a></br><a href='#110'>vecSubtract</a></br><a href='#111'>vecCross</a></br><a href='#112'>vecCrossNormalize</a></br><a href='#113'>vecLength</a></br><a href='#114'>vecNormalize</a></br><a href='#115'>vecScale</a></br><a href='#116'>vecMultiply</a></br><a href='#117'>vecAddxyz</a></br><a href='#118'>vecSetxyz</a></br><a href='#119'>vecSetPitchYaw</a></br><a href='#120'>vecFromTo</a></br><a href='#121'>vecFromToNormalize</a></br><a href='#122'>vecDot</a></br><a href='#123'>vecOrtho</a></br><a href='#124'>vecAngle</a></br><a href='#125'>vecDistance</a></br><a href='#126'>vecGetPitch</a></br><a href='#127'>vecGetYaw</a></br><a href='#128'>vecRotatex</a></br><a href='#129'>vecRotatey</a></br><a href='#130'>vecRotatez</a></br><br /><b id='101'>vecCreate(x,y,z)</b>        returns a new vector id using the given components.    vector lengths are not maintained all the time. call vecLength()<br /><br /><b id='102'>vecCreateCopy(copyVector)</b>        returns a new vector just like copyVector<br /><br /><b id='103'>vecDestroy(vector)</b>        destroys the vector<br /><br /><b id='104'>vecCopy(id,source)</b>        makes the xyz components of one vector the same as the other<br /><br /><b id='105'>vecx(vector)</b>        returns the x component of the given vector<br /><br /><b id='106'>vecy(vector)</b>        returns the y component of the given vector<br /><br /><b id='107'>vecz(vector)</b>        returns the z component of the given vector<br /><br /><b id='108'>vecAdd(result,vector,add)</b>        result equals vector plus add<br /><br /><b id='109'>vecAddScale(vResult,vPosition,vDirection,scaler)</b>            vResult equals vPosition plus vDirection scaled by scaler.     this is useful for quickly finding the position of a ray trace. <br /><br /><b id='110'>vecSubtract(result,vector,sub)</b>        result equals vector minus sub<br /><br /><b id='111'>vecCross(result,vectora,vectorb)</b>        result equals the cross product of vectora and vectorb. a cross product gives you a vector perpendicular to the other two.<br /><br /><b id='112'>vecCrossNormalize(result,vectora,vectorb)</b>        result equals the cross product of vectora and vectorb. this function also normalizes the result<br /><br /><b id='113'>vecLength(vector)</b>        returns the length of the vector. also sets the length component in the vector.<br /><br /><b id='114'>vecNormalize(vector)</b>        scales the vector to a length of one. the vectors length component must be set by calling veclength()<br /><br /><b id='115'>vecScale(vResult,vector,scaler)</b>        vResult equals vector with each component scaled by scaler<br /><br /><b id='116'>vecMultiply(result,vector,vectorMultiply)</b>        result equals vector with each component multiplied by vectorMultiply's components<br /><br /><b id='117'>vecAddxyz(vector,x,y,z)</b>        adds x y z onto each component of vector<br /><br /><b id='118'>vecSetxyz(vector,x,y,z)</b>        sets the vectors x y z components<br /><br /><b id='119'>vecSetPitchYaw(vector,pitch,yaw)</b>        sets the vectors components using yaw and pitch. the vector will be a length of one.<br /><br /><b id='120'>vecFromTo(result,fromThisPosition,toThisOne)</b>        result euqals the vector fromThisPosition toThisOne<br /><br /><b id='121'>vecFromToNormalize(result,fromThisPosition,toThisOne)</b>        same function as vecFromTo() but this normalizes the result<br /><br /><b id='122'>vecDot(vectora,vectorb)</b>        returns the dot product of the two vectors<br /><br /><b id='123'>vecOrtho(vResult,vOrtho,vector)</b>            vResult equals vOrtho orthogonal to vector.     makes vOrtho perpendicular to vector.     this alters the length of vOrtho. <br /><br /><b id='124'>vecAngle(vectora,vectorb)</b>        returns the degree angle of the two vectors<br /><br /><b id='125'>vecDistance(positiona,positionb)</b>        returns the distance between the two positions<br /><br /><b id='126'>vecGetPitch(vector)</b>        returns the pitch of the vector. assumes an up vector of 0 0 1<br /><br /><b id='127'>vecGetYaw(vector)</b>        returns the yaw of the vector. assumes an up vector of 0 0 1<br /><br /><b id='128'>vecRotatex(vector,x,y)</b>        rotates the vector around the x axis. x y should be the components of the rotation. cos(angle) and sin(angle)<br /><br /><b id='129'>vecRotatey(vector,x,y)</b>        rotates the vector around the y axis. x y should be the components of the rotation. cos(angle) and sin(angle)<br /><br /><b id='130'>vecRotatez(vector,x,y)</b>        rotates the vector around the z axis. x y should be the components of the rotation. cos(angle) and sin(angle)<br /><br /><hr><h2 id='200'>quaternion</h2><a href='#201'>quatCreate</a></br><a href='#202'>quatDestroy</a></br><a href='#203'>quatCopy</a></br><a href='#204'>quatGetVectors</a></br><a href='#205'>quatGetVecx</a></br><a href='#206'>quatGetVecy</a></br><a href='#207'>quatGetVecz</a></br><a href='#208'>quatGetEuler</a></br><a href='#209'>quatMultiply</a></br><a href='#210'>quatSetAxisAngle</a></br><a href='#211'>quatSetEuler</a></br><a href='#212'>quatClear</a></br><br /><b id='201'>quatCreate()</b>        returns a new quaternion<br /><br /><b id='202'>quatDestroy(quat)</b>        destroys the quaternion<br /><br /><b id='203'>quatCopy(id,source)</b>        makes one quaternion the same as the other.<br /><br /><b id='204'>quatGetVectors(quaternion,vForward,vSide,vUp)</b>        sets the vectors using the orientation of the quaternion. it's like calling all three quatGetVec functions at once.<br /><br /><b id='205'>quatGetVecx(quat,vRector)</b>          sets vRector to point along the quaternions x axis<br /><br /><b id='206'>quatGetVecy(quat,vRector)</b>         sets vRector to point along the quaternions y axis<br /><br /><b id='207'>quatGetVecz(quat,vRector)</b>          sets vRector to point along the quaternions z axis<br /><br /><b id='208'>quatGetEuler(quat,vResult)</b>            sets each component of vResult to the rotation of the quaternion in degrees. x=roll y=pitch z=yaw<br /><br /><b id='209'>quatMultiply(qResult,quaterniona,quaternionb)</b>        qResult equals quaterniona multiplied by quaternionb. the order the quaternions are multiplied effects the resulting rotation<br /><br /><b id='210'>quatSetAxisAngle(quat,vector,degrees)</b>           quaternion is set using axis angle format<br /><br /><b id='211'>quatSetEuler(quat,roll,pitch,yaw)</b>        quaternion is set using euler angles. roll being rotation around the x, pitch being rotation around the y, and yaw being rotation around the z axis.<br /><br /><b id='212'>quatClear(quat)</b>        quaternion will be set to a unit quaternion.<br /><br /><hr><h2 id='300'>screen convert</h2><a href='#301'>screenConvertPrep</a></br><a href='#302'>screenConvertToVector</a></br><a href='#303'>screenConvertToScreen</a></br><br /><b id='301'>screenConvertPrep(vCameraPosition,vForward,vUp,fov,screenw,screenh)</b>        prepares variables for converting 2d coordinates into vectors or 3d positions into 2d ones.     vForward and vUp vectors must be a length of one.     the fov must be between 1 and 179.     screenw and screenh must be larger than 0. <br /><br /><b id='302'>screenConvertToVector(vResult,x,y)</b>        vResult equals a vector pointing away from the camera in the direction of x y.     screenConvertPrep() must be called first and if there are changes to the camera.     if the camera doesn't move, just prep once. <br /><br /><b id='303'>screenConvertToScreen(vResult,vPosition)</b>        vResult equals the 2d position on the screen the 3d vPosition lines up to. get the x y from vResult using vecGet() functions.     screenConvertPrep() must be called first and if there are changes to the camera.     if the camera doesn't move, just prep once.     if the 2d result is not on screen, vResult is not set. <br /><br /><hr><h2 id='400'>spaces</h2><a href='#401'>spaceCreate</a></br><a href='#402'>spaceDestroy</a></br><a href='#403'>spacePrepNone</a></br><a href='#404'>spacePrepQuat</a></br><a href='#405'>spacePrepVectors</a></br><a href='#406'>spaceConvertIn</a></br><a href='#407'>spaceConvertOut</a></br><a href='#408'>spaceConvertPosIn</a></br><a href='#409'>spaceConvertPosOut</a></br><br /><b id='401'>spaceCreate(vPosition)</b>        returns a new space id.     vPosition is the vector to refrence for the position of the space.     don't delete vPosition until this space is deleted.<br /><br /><b id='402'>spaceDestroy(space)</b>        destroys the space<br /><br /><b id='403'>spacePrepNone(space)</b>        sets the orientation of the space to no orientation at all. this is the same as setting it to world coordinates.    <br /><br /><b id='404'>spacePrepQuat(space,quat)</b>        sets the orientation of the space using the quaternion.     you only have to prep when the orientation of the space changes. <br /><br /><b id='405'>spacePrepVectors(space,vForward,vSide,vUp)</b>        sets the orientation of the space using three vectors.     each vector must be a length of one and perpendicular to the others.     vForward is positive x.     vSide is positive y.     vUp is positive z.     you only have to prep when the orientation of the space changes. <br /><br /><b id='406'>spaceConvertIn(space,vResult,vector)</b>            vResult equals the vector converted into the space. make sure to prep the spaces orientation.<br /><br /><b id='407'>spaceConvertOut(space,vResult,vector)</b>        vResult equals the vector converted out of the space. this is the reverse of spaceConvertIn() make sure to prep the spaces orientation.<br /><br /><b id='408'>spaceConvertPosIn(space,vResult,vPosition)</b>            vResult equals vPosition converted into the space. the resulting position is relative of the spaces position.  make sure to prep the spaces orientation.<br /><br /><b id='409'>spaceConvertPosOut(space,vResult,vPosition)</b>        vResult equals vPosition converted out of the space. this is the reverse of spaceConvertPosIn().  make sure to prep the spaces orientation.<br /><br /><hr><h2 id='500'>shapes</h2><a href='#501'>shapeCreate</a></br><a href='#502'>shapeDestroy</a></br><a href='#503'>shapeSetPlane</a></br><a href='#504'>shapeSetTriangle</a></br><a href='#505'>shapeSetBlock</a></br><a href='#506'>shapeSetBlockInside</a></br><a href='#507'>shapeSetSphere</a></br><a href='#508'>shapeSetCylinder</a></br><a href='#509'>shapeSetCone</a></br><a href='#510'>shapeGetType</a></br><br /><b id='501'>shapeCreate()</b>    returns a new shape<br /><br /><b id='502'>shapeDestroy(shape)</b>        destroys the shape<br /><br /><b id='503'>shapeSetPlane(shape,vPosition,vNormal)</b>        sets the shapes type to a plane. the plane is defined using a position and normal<br /><br /><b id='504'>shapeSetTriangle(shape,vPointa,vPointb,vPointc,vNormal)</b>        sets the shapes type to a triangle. the triangle is defined using three points and a normal. you must calculate the normal.<br /><br /><b id='505'>shapeSetBlock(shape,vPosition,vSize)</b>        sets the shapes type to a block. the block is defined using a position and size<br /><br /><b id='506'>shapeSetBlockInside(shape,vPosition,vSize)</b>        sets the shapes type to an inside out block. the block is defined using a position and size<br /><br /><b id='507'>shapeSetSphere(shape,vPosition,radius)</b>        sets the shapes type to a sphere. the sphere is defined by a position and radius<br /><br /><b id='508'>shapeSetCylinder(shape,vPosition,height,radius)</b>        sets the shapes type to a cylinder. the cylinder is defined by a position, height, and radius.<br /><br /><b id='509'>shapeSetCone(shape,vPosition,height,radius)</b>        sets the shapes type to a cone. the cone is defined by a position, height, and radius.<br /><br /><b id='510'>shapeGetType(shape)</b>        returns the type of the shape. PLANE=0 TRIANGLE=1 BLOCK=2 SPHERE=3 CYLINDER=4 CONE=5<br /><br /><hr><h2 id='600'>ray tracing</h2><a href='#601'>rayTracePlane</a></br><a href='#602'>rayTraceTriangle</a></br><a href='#603'>rayTraceBlock</a></br><a href='#604'>rayTraceBlockInside</a></br><a href='#605'>rayTraceSphere</a></br><a href='#606'>rayTraceCylinder</a></br><a href='#607'>rayTraceCone</a></br><a href='#608'>rayTraceShape</a></br><br /><b id='601'>rayTracePlane(vPointOnPlane,vPlaneNormal,vRayPosition,vRayDirection,vNormalResult)</b>            returns the distance of the ray trace or -1 when there is no trace.     a negative distance is possible, so check that the distance returned is greater than or equal to 0.     this does not care which side of the plane you're on.    sets vNormalResult to the surface normal of the ray trace. use -1 to not set it. <br /><br /><b id='602'>rayTraceTriangle(vPointa,vPointb,vPointc,vNormal,vRayPosition,vRayDirection,vNormalResult)</b>            returns the distance of the ray trace or -1 when there is no trace.     a negative distance is possible, so check that the distance returned is greater than or equal to 0.     this does not care which side of the triangle you're on.    sets vNormalResult to the surface normal of the ray trace. use -1 to not set it.     King Stephan wrote the original version of this<br /><br /><b id='603'>rayTraceBlock(vBoxPosition,vBoxSize,vRayPosition,vRayDirection,vNormalResult)</b>            returns the distance of the ray trace or -1 when there is no trace.     sets vNormalResult to the surface normal of the ray trace. use -1 to not set it.     the rayPosition must be outside of the block to successfully ray trace it. <br /><br /><b id='604'>rayTraceBlockInside(vBoxPosition,vBoxSize,vRayPosition,vRayDirection,vNormalResult)</b>            returns the distance of the ray trace or -1 when there is no trace.     sets vNormalResult to the surface normal of the ray trace. use -1 to not set it.     the rayPosition must can be inside or outside the block to ray trace it.     this ray traces the iside of the box walls only.<br /><br /><b id='605'>rayTraceSphere(spherePosition,radius,rayPosition,rayDirection,vNormalResult)</b>            returns the distance of the ray trace or -1 when there is no trace.     sets vNormalResult to the normal of the ray trace. use -1 to not set it.     the rayPosition must be outside of the sphere to successfully ray trace it.     Tepi wrote the original version of this. <br /><br /><b id='606'>rayTraceCylinder(vPosition,height,radius,vRayPosition,vRayDirection,vNormalResult)</b>            the cylinder stands up and down in the z axis.     sets vNormalResult to the surface normal of the ray trace. use -1 to not set it.     you must be outside of the cylinder to ray trce it.     returns the distance of the ray trace or -1 when there is no trace.     Tepi wrote the original version of this. <br /><br /><b id='607'>rayTraceCone(vConePosition,height,radius,vRayPosition,vRayDirection,vNormalResult)</b>            returns the distance of the ray trace or -1 when there is no trace.     you must be outside of the cone to ray trce it.     height and radius must be larger than 0. <br /><br /><b id='608'>rayTraceShape(shape,vRayPosition,vRayDirection,vNormalResult)</b>            returns the distance of the ray trace or -1 when there is no trace.    this ray trace can only happen in unrotated axis aligned space.     if the shape is rotated you must use the space scripts to    convert the ray from world space into the shapes space.    WILL NOT RAY TRACE CONE SHAPES<br /><br /><hr><h2 id='700'>extra tracing</h2><a href='#701'>extraTracePlane</a></br><a href='#702'>extraTraceBlock</a></br><a href='#703'>extraTraceCylinder</a></br><a href='#704'>extraTraceSphere</a></br><a href='#705'>extraTraceCone</a></br><a href='#706'>extraTraceShape</a></br><br /><b id='701'>extraTracePlane(vPointOnPlane,vPlaneNormal,vRayPosition,vRayDirection,extraDistace,vNormalResult)</b>            this ray traces a block onto a plane by using extraDistace.     returns the distance of the ray trace or -1 when there is no trace.     a negative distance is possible, so check that the distance returned is greater than or equal to 0.     this does not care which side of the plane you're on.     sets vNormalResult to the surface normal of the ray trace. use -1 to not set it. <br /><br /><b id='702'>extraTraceBlock(vBoxPosition,vBoxSize,vRayPosition,vRayDirection,halfSize,vNormalResult)</b>              ray traces a block onto another block.     the block being ray traced onto uses it's corner as it's origin.     the block doing the ray trace has a halfSize and centered origin.     returns the distance of the ray trace or -1 when there is no trace.     sets vNormalResult to the surface normal of the ray trace. use -1 to not set it. <br /><br /><b id='703'>extraTraceCylinder(vCylinderPosition,cylinderHeight,cylinderRadius,vRayPosition,vRayDirection,extraDistance,vNormalResult)</b>            ray traces onto a cylinder with extraDistance added onto the cylinderHeight and cylinderRadius.     returns the distance of the ray trace or -1 when there is no trace.     sets vNormalResult to the surface normal of the ray trace. use -1 to not set it. <br /><br /><b id='704'>extraTraceSphere(vSpherePosition,radius,vRayPosition,vRayDirection,extraTrace,vNormalResult)</b>            this ray traces a sphere onto another sphere.     the first two arguments are the sphere you'll be sphere tracing onto.     returns the distance of the ray trace or -1 when there is no trace.     sets vNormalResult to the surface normal of the ray trace. use -1 to not set it. <br /><br /><b id='705'>extraTraceCone(vConePosition,coneHeight,coneRadius,vRayPosition,vRayDirection,extraDistance,vNormalResult)</b>            ray traces onto a cone with extraDistance added onto the coneHeight and coneRadius.     returns the distance of the ray trace or -1 when there is no trace.     sets vNormalResult to the surface normal of the ray trace. use -1 to not set it. <br /><br /><b id='706'>extraTraceShape(shape,vRayPosition,vRayDirection,extraDistance,vNormalResult)</b>            returns the distance of the ray trace or -1 when there is no trace.     this ray trace can only happen in unrotated axis aligned space.     if the shape is rotated you must use the space scripts to convert the ray from world space into the shapes space.     will not ray trace triangles<br /><br /><hr><h2 id='800'>3d grids</h2><a href='#801'>grid3dCreate</a></br><a href='#802'>grid3dDestroy</a></br><a href='#803'>grid3dSet</a></br><a href='#804'>grid3dGet</a></br><a href='#805'>grid3dGetSizex</a></br><a href='#806'>grid3dGetSizey</a></br><a href='#807'>grid3dGetSizez</a></br><a href='#808'>grid3dResize</a></br><a href='#809'>grid3dCopy</a></br><a href='#810'>grid3dClear</a></br><a href='#811'>grid3dCopyRegion</a></br><a href='#812'>grid3dWrite</a></br><a href='#813'>grid3dRead</a></br><br /><b id='801'>grid3dCreate(sizex,sizey,sizez)</b>            returns a new 3d grid id.<br /><br /><b id='802'>grid3dDestroy(grid)</b>            destroys the 3d grid<br /><br /><b id='803'>grid3dSet(grid,cellx,celly,cellz,value)</b>                sets the cell in the 3d grid to the value<br /><br /><b id='804'>grid3dGet(grid,cellx,celly,cellz)</b>                returns the value in the cell of the 3d grid.<br /><br /><b id='805'>grid3dGetSizex(grid)</b>        returns the size of the grid in the x  <br /><br /><b id='806'>grid3dGetSizey(grid)</b>        returns the size of the grid in the y  <br /><br /><b id='807'>grid3dGetSizez(grid)</b>        returns the size of the grid in the z  <br /><br /><b id='808'>grid3dResize(grid,sizex,sizey,sizez)</b>            resizes the grid to the new dimensions. use 0 to not change size for a component. <br /><br /><b id='809'>grid3dCopy(id,source)</b>            makes one grid the same as the other<br /><br /><b id='810'>grid3dClear(grid,value)</b>        sets all the cells in the 3d grid to the value. value can be real or string.<br /><br /><b id='811'>grid3dCopyRegion(id,source,ax,ay,az,bx,by,bz,posx,posy,posz)</b>            copys the region from source to id.     ax ay az is the top left bottom of the region.     bx by bz is the bottom right top of the region.     don't pass in a region that is not inside grid source.     posx posy posz indicate the position to place the region into grid id. it must be inside id.    if the region doesn't fit into grid id then some data will not be copied<br /><br /><b id='812'>grid3dWrite(file,grid)</b>            writes all the grids data to a file.     file must be an open writable text file. <br /><br /><b id='813'>grid3dRead(file,grid)</b>            reads the grid from file.     file must be an open readable text file. <br /><br /><hr><h2 id='900'>files and strings</h2><a href='#901'>readFiles</a></br><a href='#902'>stringExtract</a></br><a href='#903'>getNumber</a></br><a href='#904'>fileTextWriteString</a></br><a href='#905'>fileTextWriteReal</a></br><a href='#906'>fileTextReadString</a></br><a href='#907'>fileTextReadReal</a></br><a href='#908'>fileBinReadWord</a></br><a href='#909'>fileBinWriteWord</a></br><a href='#910'>fileBinWriteInt</a></br><a href='#911'>fileBinReadInt</a></br><a href='#912'>fileBinWriteString</a></br><a href='#913'>fileBinReadString</a></br><br /><b id='901'>readFiles(startDirectory,extension,dsList)</b>        This searches all files under the specified directory.     File names are saved in a ds_list which is supplied by the user.     startDirectory is the name of the directory to start searching.     extension is the part of the files to be found (including the period, and must be in lower case.)     dsList is the data structure to save the file names in. <br /><br /><b id='902'>stringExtract(string,tokenString,index)</b>            Returns the element at the given index within a given string of elements.     string is the complete string you want to extract other strings from.     tokenString is the character or string seperating the elements in string.     index is the element to return, {0..n-1}     Example: stringExtract("cat,dog,mouse",",",1) = "dog" GMLscripts.com<br /><br /><b id='903'>getNumber(text,defualt)</b>                asks the user for a number.     returns a number with a decimal point and negative sign.     text is the text to display.     default is the default value shown.     does not get numbers with more than 10 characters because real() can't handle a huge number.<br /><br /><b id='904'>fileTextWriteString(file,string)</b>                writes the string to the file and a new line<br /><br /><b id='905'>fileTextWriteReal(file,real)</b>            writes the real to the file and a new line<br /><br /><b id='906'>fileTextReadString(file)</b>       reads a string from the file and a new line. returns the string. <br /><br /><b id='907'>fileTextReadReal(file)</b>                reads the real from the file and a new line. returns the real. <br /><br /><b id='908'>fileBinReadWord(file,size,binend)</b>        returns an integer word of the given size from the given file.     file is an open binary file.     size is the word in bytes.     bigend is whether to use big-endian byte order or not.     GMLscripts.com<br /><br /><b id='909'>fileBinWriteWord(file,size,bigend,value)</b>    writes the integer value to the file using size bytes and big or small endian.     returns nothing. GMLscripts.com<br /><br /><b id='910'>fileBinWriteInt(file,value)</b>                writes the value to the file.     reads using big endian.     the value must be larger than 0 and smaller than 65536.     does not save decimal values.<br /><br /><b id='911'>fileBinReadInt(file)</b>                reads two bytes and returns an integer value.     uses big endian byte order. <br /><br /><b id='912'>fileBinWriteString(file,string)</b>        writes the string to the open binary file.     the characters are written one byte at a time and a null is placed at the end. <br /><br /><b id='913'>fileBinReadString(file)</b>        reads a string from the open binary file and returns it.     stops reading characters when 0 is read (NULL)<br /><br /><hr><h2 id='1000'>other</h2><a href='#1001'>d3dSetProjectionQuat</a></br><a href='#1002'>d3dSetProjection</a></br><a href='#1003'>d3dTransform</a></br><a href='#1004'>d3dSetOrtho</a></br><a href='#1005'>d3dLightDefineDirection</a></br><a href='#1006'>d3dModelBlock</a></br><a href='#1007'>d3dDrawBlock</a></br><br /><b id='1001'>d3dSetProjectionQuat(vPosition,qRotation,fov,aspect,znear,zfar)</b>        sets the projection using a position and rotation<br /><br /><b id='1002'>d3dSetProjection(vPosition,vForward,vUp,fov,aspect,znear,zfar)</b>        sets the projection using vectors<br /><br /><b id='1003'>d3dTransform(vPosition,qRotation)</b>        does a rotate and translate transformation using a position and rotation<br /><br /><b id='1004'>d3dSetOrtho(w,h)</b>        sets a basic orthographic projection. hidden 0, lighting 0, sets drawing color to black.<br /><br /><b id='1005'>d3dLightDefineDirection(vDirection,ind,color)</b>        defines a directional light using a vector<br /><br /><b id='1006'>d3dModelBlock(model,vPosition,vSize,hrepeat,vrepeat)</b>        models a block using a position and size<br /><br /><b id='1007'>d3dDrawBlock(vPosition,radius)</b>        draws a block using a position and radius. useful for debugging<br /><br /><hr></body></html>